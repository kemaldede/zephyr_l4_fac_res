#include <zephyr/types.h>
#include <stddef.h>
#include <string.h>
#include <errno.h>
#include <zephyr.h>
#include <device.h>
#include <drivers/gpio.h>
#include <sys/printk.h>

#include <bluetooth/bluetooth.h>
#include <bluetooth/hci.h>
#include <bluetooth/conn.h>
#include <bluetooth/uuid.h>
#include <bluetooth/gatt.h>
#include <settings/settings.h>

#include <services/custom_service.h>
#include <utils/rssi.h>


#define DEVICE_NAME CONFIG_BT_DEVICE_NAME
#define DEVICE_NAME_LEN (sizeof(DEVICE_NAME) - 1)

#define GPIO_PORT	"GPIO_0"

#define	BUTTON1_PIN	13
#define LED1_PIN	17

void my_timer_handler(struct k_timer *dummy);
void button1_work_handler(struct k_work *work) ;

static struct gpio_callback button1_cb_data;
static struct k_work button1_work;
const struct device *my_gpio_port;
struct k_timer my_timer;

static bool paired = false;
static bool button_press = false;

struct bt_conn *default_conn;

int sampling = 0;

static const struct bt_data ad[] = {
		BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),
		BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN),
};

// passkey is generated by the stack and provided in callback for display to the user
static void pairing_passkey_display(struct bt_conn *conn, unsigned int passkey)
{
	char addr[BT_ADDR_LE_STR_LEN];
	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
	printk("Passkey for %s: %06u\n", addr, passkey);
}

static void auth_confirm(struct bt_conn *conn, unsigned int passkey)
{
	default_conn = conn;
	char addr[BT_ADDR_LE_STR_LEN];
	char passkey_str[7];
	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
	snprintk(passkey_str, 7, "%06u", passkey);
	printk("\nConfirm passkey for %s: %s\n\n", addr, passkey_str);
	printk("Automatic confirm passkey\n"); // I will add RSSI check for future developments
	if(paired == false)
	{
		printk("User indicated YES\n");
		bt_conn_auth_passkey_confirm(default_conn);
		paired = true;
	}
}

static void pairing_cancel(struct bt_conn *conn)
{
	printk("Pairing cancelled\n");
	paired = false;
}

// will result in Numeric Comparison being used
static struct bt_conn_auth_cb pairing_cb_display = {
		.passkey_display = pairing_passkey_display,
		.passkey_confirm = auth_confirm,
		.cancel = pairing_cancel,
};

static void connected(struct bt_conn *conn, uint8_t err)
{
	if (err)
	{
		printk("Not Connected : %d", err);
	}
	else
	{
		printk("Connected\n");
		default_conn = bt_conn_ref(conn);
		int rc = bt_conn_set_security(default_conn, BT_SECURITY_L4);
		printk("requested security level 4 [%d]\n",rc);
    	// start_sampling_rssi();
	}
}

static void disconnected(struct bt_conn *conn, uint8_t reason)
{
	if (default_conn)
	{
		printk("Disconnected\n");
		bt_conn_unref(default_conn);
		default_conn = NULL;
    	// sampling = 0;
	}
}

static void security_level_changed(struct bt_conn *conn, bt_security_t level, enum bt_security_err err)
{
	printk("security_level_changed to %d\n", level);
}

static struct bt_conn_cb conn_callbacks = {
		.connected = connected,
		.disconnected = disconnected,
		.security_changed = security_level_changed,
};

static void bt_ready(int err)
{
	if (err)
	{
		return;
	}

	custom_service_init();

	if (IS_ENABLED(CONFIG_SETTINGS))
	{
		settings_load();
	}

	err = bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), NULL, 0);
	if (err)
	{
		return;
	}
}

void clear_all_bonds()
{
	/** Clear pairing information.
  *
  * @param id    Local identity (mostly just BT_ID_DEFAULT).
  * @param addr  Remote address, NULL or BT_ADDR_LE_ANY to clear all remote
  *              devices.
  *
  * @return 0 on success or negative error value on failure.
  */
	printk("clearing all bonds\n");
	paired = false;
	int rc = bt_unpair(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
	printk("done [%d]\n", rc);
}

void button1_pressed(const struct device *port,
					struct gpio_callback *cb,
					gpio_port_pins_t pins)
{
	int ret;
	if(button_press == false)
	{
		printk("Button1 work is pressed\n");
		button_press = true;
		k_work_init(&button1_work, button1_work_handler);
		ret = k_work_submit(&button1_work);
		if(ret == 0)
		{
			printk("Button1 work is already in queue\n");
		}
	}	
}

void button1_work_handler(struct k_work *work) 
{
	k_timer_start(&my_timer, K_SECONDS(6), K_NO_WAIT);
	k_work_cancel(&button1_work);
}

void my_timer_handler(struct k_timer *dummy)
{
	printk("Timer expiry function worked\n");
	int val = gpio_pin_get(my_gpio_port,BUTTON1_PIN);
	if( val == 0){
		clear_all_bonds();	
		gpio_pin_toggle(my_gpio_port,LED1_PIN);
		k_msleep(1000);
		__NVIC_SystemReset();
		k_msleep(100);
	}  
	button_press = false; 
}

void init_timer(){
	k_timer_init(&my_timer, my_timer_handler, NULL);
}

void configure_gpios()
{
	int ret;

	my_gpio_port = device_get_binding(GPIO_PORT);

	gpio_pin_configure(my_gpio_port,BUTTON1_PIN , GPIO_INPUT | GPIO_PULL_UP);
	gpio_pin_configure(my_gpio_port, LED1_PIN , GPIO_OUTPUT | GPIO_OUTPUT_ACTIVE);

	gpio_init_callback(&button1_cb_data, button1_pressed, BIT(BUTTON1_PIN));
	gpio_add_callback(my_gpio_port, &button1_cb_data);

	gpio_pin_interrupt_configure(my_gpio_port, BUTTON1_PIN, GPIO_INT_EDGE_TO_INACTIVE);
}

void main(void)
{
	int err;
	printk("Starting....\n");
	configure_gpios();
	init_timer();

	err = bt_enable(bt_ready);
	if (err)
	{
		return;
	}

	clear_all_bonds();

	bt_conn_cb_register(&conn_callbacks);

	bt_conn_auth_cb_register(&pairing_cb_display);
}